<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0">
        <style>
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            html,
            body {
                height: 100%;
            }

            body {
                overflow: hidden;
            }
        </style>
    </head>

    <body>
        <script type="importmap">
            {
                "imports": {
                    "voyd": "../dist/voyd.js"
                }
            }
        </script>

        <canvas is="gpu-canvas"></canvas>

        <script type="module">
            import {
                Geometry,
                GPUContext,
                IndexBuffer,
                Matrix3,
                PerspectiveCamera,
                OrthographicCamera,
                VertexAttribute,
                VertexBuffer,
                VertexBufferLayout,
                GPUCanvas,
                PlaneGeometry,
                CircleGeometry,
                SphereGeometry,
                ControlsPipeline,
                WalkBehavior,
                LookBehavior,
                OrbitBehavior,
                FlyControls,
                FirstPersonControls,
                OrbitControls,
                Vector3,
            } from 'voyd';

            const canvasElement = document.querySelector('canvas');
            const canvasContext = canvasElement.getContext('webgpu');

            await GPUContext.init();

            canvasContext.configure({
                device: GPUContext.device,
                format: GPUContext.preferredFormat,
            });

            // const camera = new OrthographicCamera();
            const camera = new PerspectiveCamera(90);

            camera.position.set(0, 0, -2);
            // camera.target.set(1, -2, 0);

            console.log(camera);

            // const controls = new OrbitControls(camera);
            const controls = new FlyControls(canvasElement, camera);

            console.log(controls);

            const geometry = new PlaneGeometry(4, 4, 64, 64);
            // const geometry = new CircleGeometry(1, 4);
            // const geometry = new SphereGeometry(1, 32, 32);

            geometry.setTopology('triangle-list');

            console.log(geometry);

            const vertexBuffer = VertexBuffer.fromGeometry(geometry, 0, true);
            const vertexBufferLayout = VertexBufferLayout.fromGeometry(geometry);

            const indexBuffer = new IndexBuffer(geometry.indices, 0, true);

            const renderShader = GPUContext.device.createShaderModule({
                code: `
                    struct VertexInput {
                        @location(0) position: vec3f,
                        @location(1) normal: vec3f,
                        @location(2) uv: vec2f
                    }

                    struct VertexOutput {
                        @builtin(position) position: vec4f,
                        @location(0) vertex: vec3f,
                        @location(1) normal: vec3f,
                        @location(2) uv: vec2f
                    }

                    @group(0) @binding(0) var<uniform> projection_matrix: mat4x4f;
                    @group(0) @binding(1) var<uniform> view_matrix: mat4x4f;

                    @vertex
                    fn vs(input: VertexInput) -> VertexOutput {
                        var output: VertexOutput;

                        output.position = projection_matrix * view_matrix * vec4f(input.position, 1);
                        output.vertex = input.position;
                        output.normal = input.normal;
                        output.uv = input.uv;

                        return output;
                    }

                    @fragment
                    fn fs(input: VertexOutput) -> @location(0) vec4f {
                        var vertex_color = 1 - smoothstep(0, 1, 4 * input.vertex.z);
                        // var vertex_color = 1f;

                        return vec4f(vec3f(vertex_color), 1);
                    }
                `,
            });

            const bindGroupLayout = GPUContext.device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {
                            type: 'uniform'
                        }
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {
                            type: 'uniform'
                        }
                    },
                ]
            });

            const bindGroup = GPUContext.device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: camera.projectionMatrixBuffer.instance,
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: camera.viewMatrixBuffer.instance
                        }
                    }
                ]
            });

            const renderPipelineLayout = GPUContext.device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });

            const renderPipeline = GPUContext.device.createRenderPipeline({
                layout: renderPipelineLayout,
                vertex: {
                    module: renderShader,
                    entryPoint: 'vs',
                    buffers: [vertexBufferLayout],
                },
                fragment: {
                    module: renderShader,
                    entryPoint: 'fs',
                    targets: [
                        {
                            format: GPUContext.preferredFormat
                        }
                    ]
                },
                primitive: {
                    topology: geometry.topology,
                    // stripIndexFormat: geometry.indexFormat
                }
            });

            const renderBundleEncoder = GPUContext.device.createRenderBundleEncoder({ colorFormats: [GPUContext.preferredFormat] });

            renderBundleEncoder.setPipeline(renderPipeline);
            renderBundleEncoder.setBindGroup(0, bindGroup);
            renderBundleEncoder.setVertexBuffer(0, vertexBuffer.instance);
            renderBundleEncoder.setIndexBuffer(indexBuffer.instance, geometry.indexFormat);
            renderBundleEncoder.drawIndexed(geometry.indices.length);

            const renderBundle = renderBundleEncoder.finish();

            let t0;
            let t1;

            requestAnimationFrame(loop);

            function loop() {
                t1 = performance.now();

                const deltaTime = (t1 - t0) / 1000;

                controls.update(deltaTime);
                camera.setAspectRatio(canvasElement.aspectRatio);
                camera.update();

                const commandEncoder = GPUContext.device.createCommandEncoder();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [
                        {
                            loadOp: 'clear',
                            storeOp: 'store',
                            clearValue: [0, 0, 0, 1],
                            view: canvasContext.getCurrentTexture().createView()
                        }
                    ]
                });

                renderPass.executeBundles([renderBundle]);
                renderPass.end();

                GPUContext.device.queue.submit([commandEncoder.finish()]);

                t0 = t1;

                requestAnimationFrame(loop);
            }
        </script>
    </body>
</html>